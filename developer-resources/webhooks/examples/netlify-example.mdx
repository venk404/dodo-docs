---
title: 'Netlify Functions'
description: 'Deploy DodoPayments webhooks to Netlify Functions'
icon: 'diamond'
---

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/cloud-functions/tree/main/netlify">
  Complete source code and setup guide
</Card>

## Quick Setup

### 1. Prerequisites
- [Netlify account](https://app.netlify.com/signup)
- [Neon database](https://neon.tech) account
- DodoPayments webhook key from [dashboard](https://app.dodopayments.com/developer/webhooks)

### 2. Install & Deploy

```bash
npm install -g netlify-cli
netlify login
git clone https://github.com/dodopayments/cloud-functions.git
cd cloud-functions/netlify
npm install
```

### 3. Database Setup

1. Sign up for [Neon](https://neon.tech)
2. Create a new project
3. Open the SQL Editor
4. Copy and paste the contents of [`schema.sql`](#database-schema)
5. Run the query
6. Get your connection string from Neon ‚Üí Connection Details

### 4. Set Environment Variables

```bash
netlify env:set DATABASE_URL "your-neon-connection-string"
netlify env:set DODO_PAYMENTS_WEBHOOK_KEY "your-webhook-key"
```

Or set them in [Netlify Dashboard](https://app.netlify.com) ‚Üí Site Settings ‚Üí Environment Variables

### 5. Initialize & Deploy

```bash
netlify init       # Link to your site (first time only)
npm run deploy
```

**Webhook URL:** `https://[your-site].netlify.app/.netlify/functions/webhook`

## What It Does

Processes subscription events and stores them in PostgreSQL:
- **subscription.active** - Creates/updates customer and subscription records
- **subscription.cancelled** - Marks subscription as cancelled
- **subscription.renewed** - Updates next billing date

## Key Features

‚úÖ **Signature verification** - Using the standardwebhooks library  
‚úÖ **Idempotency** - Prevents duplicate processing with webhook IDs  
‚úÖ **Event logging** - Complete audit trail in `webhook_events` table  
‚úÖ **Error handling** - Logged and retryable

## Configuration Files

<CodeGroup>
  ```json package.json
  {
    "name": "dodo-webhook-netlify",
    "version": "1.0.0",
    "type": "module",
    "description": "DodoPayments Webhook Handler for Netlify",
    "scripts": {
      "dev": "netlify dev",
      "deploy": "netlify deploy --prod"
    },
    "dependencies": {
      "@neondatabase/serverless": "^1.0.2",
      "standardwebhooks": "^1.0.0"
    },
    "devDependencies": {
      "@netlify/functions": "^5.0.0",
      "netlify-cli": "^23.9.1",
      "typescript": "^5.9.3"
    }
  }
  ```

  ```json tsconfig.json
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "lib": ["ES2022"],
      "moduleResolution": "node",
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "forceConsistentCasingInFileNames": true,
      "isolatedModules": true,
      "types": ["node"]
    },
    "include": ["functions/*.ts"],
    "exclude": ["node_modules"]
  }
  ```

  ```toml netlify.toml
  [build]
    functions = "functions"

  [build.environment]
    NODE_VERSION = "18"

  [functions]
    # Functions will be available at /.netlify/functions/[function-name]
    directory = "functions"
  ```
</CodeGroup>

## Database Schema

<CodeGroup>
  ```sql schema.sql expandable
  -- DodoPayments Webhook Database Schema
  -- Compatible with PostgreSQL (Supabase, Neon, etc.)

  -- Enable UUID extension (if not already enabled)
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

  -- Customers table
  CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL,
    name TEXT,
    dodo_customer_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Subscriptions table
  CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID REFERENCES customers(id) ON DELETE CASCADE,
    dodo_subscription_id TEXT UNIQUE NOT NULL,
    product_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'active', 'cancelled', 'expired', 'paused')),
    billing_interval TEXT CHECK (billing_interval IN ('day', 'week', 'month', 'year')),
    amount NUMERIC(10, 2),
    currency TEXT DEFAULT 'USD',
    next_billing_date TIMESTAMP WITH TIME ZONE,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Webhook events log
  CREATE TABLE IF NOT EXISTS webhook_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_id TEXT UNIQUE,
    event_type TEXT NOT NULL,
    data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    attempts INTEGER DEFAULT 0
  );

  -- Indexes for better query performance
  CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
  CREATE INDEX IF NOT EXISTS idx_customers_dodo_id ON customers(dodo_customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_dodo_id ON subscriptions(dodo_subscription_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_customer_id ON subscriptions(customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_type ON webhook_events(event_type);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_webhook_id ON webhook_events(webhook_id);

  -- Function to automatically update updated_at timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  -- Triggers to automatically update updated_at
  CREATE TRIGGER update_customers_updated_at
    BEFORE UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  -- Comments for documentation
  COMMENT ON TABLE customers IS 'Stores customer information from DodoPayments';
  COMMENT ON TABLE subscriptions IS 'Stores subscription data from DodoPayments';
  COMMENT ON TABLE webhook_events IS 'Logs all incoming webhook events for audit and retry purposes';

  COMMENT ON COLUMN customers.dodo_customer_id IS 'Unique customer ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.dodo_subscription_id IS 'Unique subscription ID from DodoPayments';
  COMMENT ON COLUMN webhook_events.attempts IS 'Number of processing attempts for failed webhooks';
  COMMENT ON COLUMN webhook_events.data IS 'Full webhook payload as JSON';
  ```
</CodeGroup>

**Tables created:**
- **customers** - Email, name, dodo_customer_id
- **subscriptions** - Status, amount, next_billing_date, linked to customers
- **webhook_events** - Event log with webhook_id for idempotency

## Implementation Code

<CodeGroup>
```typescript functions/webhook.ts expandable
import { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
import { neon } from '@neondatabase/serverless';
import { Webhook } from 'standardwebhooks';

interface WebhookPayload {
  business_id: string;
  type: string;
  timestamp: string;
  data: {
    payload_type: "Subscription" | "Refund" | "Dispute" | "LicenseKey";
    subscription_id?: string;
    customer?: {
      customer_id: string;
      email: string;
      name: string;
    };
    product_id?: string;
    status?: string;
    recurring_pre_tax_amount?: number;
    payment_frequency_interval?: string;
    next_billing_date?: string;
    cancelled_at?: string;
    currency?: string;
  };
}

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, webhook-id, webhook-signature, webhook-timestamp',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

async function handleSubscriptionEvent(sql: any, data: any, status: string) {
  if (!data.customer?.customer_id || !data.subscription_id) {
    throw new Error('Missing required fields: customer_id or subscription_id');
  }

  console.log('üîÑ Processing subscription event:', JSON.stringify(data, null, 2));

  const customer = data.customer;

  // Upsert customer (create if doesn't exist, otherwise use existing)
  const customerResult = await sql`
    INSERT INTO customers (email, name, dodo_customer_id, created_at)
    VALUES (${customer.email}, ${customer.name || customer.email}, ${customer.customer_id}, ${new Date().toISOString()})
    ON CONFLICT (dodo_customer_id) 
    DO UPDATE SET 
      email = EXCLUDED.email,
      name = EXCLUDED.name,
      updated_at = ${new Date().toISOString()}
    RETURNING id
  `;

  const customerId = customerResult[0].id;
  console.log(`‚úÖ Customer upserted with ID: ${customerId}`);

  // Upsert subscription
  await sql`
    INSERT INTO subscriptions (
      customer_id, dodo_subscription_id, product_id, status, 
      billing_interval, amount, currency, next_billing_date, cancelled_at, updated_at
    )
    VALUES (
      ${customerId}, ${data.subscription_id},
      ${data.product_id || 'unknown'}, ${status},
      ${data.payment_frequency_interval?.toLowerCase() || 'month'}, ${data.recurring_pre_tax_amount || 0},
      ${data.currency || 'USD'}, ${data.next_billing_date || null},
      ${data.cancelled_at || null}, ${new Date().toISOString()}
    )
    ON CONFLICT (dodo_subscription_id) 
    DO UPDATE SET 
      status = EXCLUDED.status,
      next_billing_date = EXCLUDED.next_billing_date,
      cancelled_at = EXCLUDED.cancelled_at,
      updated_at = EXCLUDED.updated_at
  `;

  console.log(`‚úÖ Subscription upserted with ${status} status`)
}

export const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: 'ok'
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const rawBody = event.body || '';
    console.log('üì® Webhook received');

    const DATABASE_URL = process.env.DATABASE_URL;
    const WEBHOOK_KEY = process.env.DODO_PAYMENTS_WEBHOOK_KEY;

    if (!DATABASE_URL) {
      console.error('‚ùå Missing DATABASE_URL environment variable');
      return {
        statusCode: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Server configuration error' })
      };
    }

    // Initialize Neon client
    const sql = neon(DATABASE_URL);

    // Verify webhook signature (required for security)
    if (!WEBHOOK_KEY) {
      console.error('‚ùå DODO_PAYMENTS_WEBHOOK_KEY is not configured');
      return {
        statusCode: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Webhook verification key not configured' })
      };
    }

    const webhookHeaders = {
      'webhook-id': event.headers['webhook-id'] || '',
      'webhook-signature': event.headers['webhook-signature'] || '',
      'webhook-timestamp': event.headers['webhook-timestamp'] || '',
    };

    try {
      const wh = new Webhook(WEBHOOK_KEY);
      await wh.verify(rawBody, webhookHeaders);
      console.log('‚úÖ Webhook signature verified');
    } catch (error) {
      console.error('‚ùå Webhook verification failed:', error);
      return {
        statusCode: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Webhook verification failed' })
      };
    }

    const payload: WebhookPayload = JSON.parse(rawBody);
    const eventType = payload.type;
    const eventData = payload.data;
    const webhookId = event.headers['webhook-id'] || '';

    console.log(`üìã Webhook payload:`, JSON.stringify(payload, null, 2));

    // Check for duplicate webhook-id (idempotency)
    if (webhookId) {
      const existingEvent = await sql`
        SELECT id FROM webhook_events WHERE webhook_id = ${webhookId}
      `;

      if (existingEvent.length > 0) {
        console.log(`‚ö†Ô∏è Webhook ${webhookId} already processed, skipping (idempotency)`);
        return {
          statusCode: 200,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          body: JSON.stringify({ success: true, message: 'Webhook already processed' })
        };
      }
    }

    // Log webhook event with webhook_id for idempotency
    const logResult = await sql`
      INSERT INTO webhook_events (webhook_id, event_type, data, processed, created_at)
      VALUES (${webhookId || null}, ${eventType}, ${JSON.stringify(eventData)}, ${false}, ${new Date().toISOString()})
      RETURNING id
    `;

    const loggedEventId = logResult[0].id;
    console.log('üìù Webhook event logged with ID:', loggedEventId);

    console.log(`üîÑ Processing: ${eventType} (${eventData.payload_type || 'unknown payload type'})`);

    try {
      switch (eventType) {
        case 'subscription.active':
          await handleSubscriptionEvent(sql, eventData, 'active');
          break;
        case 'subscription.cancelled':
          await handleSubscriptionEvent(sql, eventData, 'cancelled');
          break;
        case 'subscription.renewed':
          console.log('üîÑ Subscription renewed - keeping active status and updating billing date');
          await handleSubscriptionEvent(sql, eventData, 'active');
          break;
        default:
          console.log(`‚ÑπÔ∏è Event ${eventType} logged but not processed (no handler available)`);
      }

      await sql`
        UPDATE webhook_events 
        SET processed = ${true}, processed_at = ${new Date().toISOString()}
        WHERE id = ${loggedEventId}
      `;

      console.log('‚úÖ Webhook marked as processed');
    } catch (processingError) {
      console.error('‚ùå Error processing webhook event:', processingError);

      await sql`
        UPDATE webhook_events 
        SET processed = ${false}, 
            error_message = ${processingError instanceof Error ? processingError.message : 'Unknown error'},
            processed_at = ${new Date().toISOString()}
        WHERE id = ${loggedEventId}
      `;

      throw processingError;
    }

    console.log('‚úÖ Webhook processed successfully');

    return {
      statusCode: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        success: true,
        event_type: eventType,
        event_id: loggedEventId
      })
    };

  } catch (error) {
    console.error('‚ùå Webhook processing failed:', error);
    return {
      statusCode: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Webhook processing failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};
```
</CodeGroup>

## How It Works

The webhook handler:
1. **Verifies the signature** - Ensures the request is from DodoPayments using HMAC-SHA256
2. **Checks for duplicates** - Uses webhook ID to prevent processing the same event twice
3. **Logs the event** - Stores raw webhook in `webhook_events` table for audit trail
4. **Processes the event** - Creates or updates customers and subscriptions in Neon
5. **Handles errors** - Logs failures and marks event as unprocessed for retry

## Testing

**Local development:**
```bash
npm run dev  # Available at http://localhost:8888/.netlify/functions/webhook
```

**View logs in Netlify Dashboard:**
1. Select your site ‚Üí **Functions** tab
2. Click on the `webhook` function
3. View real-time logs and invocation history

**Configure in DodoPayments Dashboard:**
1. Go to Developers ‚Üí Webhooks
2. Add endpoint with your Netlify Functions URL
3. Enable: subscription.active, subscription.cancelled, subscription.renewed

## Common Issues

| Issue | Solution |
|-------|----------|
| Verification failed | Check webhook key is correct from DodoPayments dashboard |
| Database connection error | Verify Neon connection string and use pooled connection |
| Function not found (404) | Run `netlify init` and `npm run deploy` again |
| Env vars not available | Set variables in CLI or dashboard, then redeploy |

## Resources

- [Netlify Functions Docs](https://docs.netlify.com/functions/overview/)
- [Netlify CLI](https://docs.netlify.com/cli/get-started/)
- [Neon Docs](https://neon.tech/docs/)
- [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)
- [GitHub Repo](https://github.com/dodopayments/cloud-functions/tree/main/netlify)
